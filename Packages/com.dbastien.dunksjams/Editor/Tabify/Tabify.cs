#if UNITY_EDITOR

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEditor.Callbacks;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;
using UnityEngine.UIElements;
using Type = System.Type;
using Delegate = System.Delegate;
using Action = System.Action;
using static EditorGUIUtil;
using static ColorExtensions;
using static AssetDatabaseExtensions;
using static ReflectionUtils;
using Object = UnityEngine.Object;
using PackageInfo = UnityEditor.PackageManager.PackageInfo;

public static class Tabify
{
    // Helper functions - made internal/public for access from TabifyGUI and TabifyAddTabWindow
    internal static bool IconButton
        (Rect rect, string iconName, int iconSize, Color colorNormal, Color colorHovered, Color colorPressed)
    {
        GUIContent icon = EditorGUIUtility.IconContent(name: iconName);
        if (icon?.image == null) return false;

        bool isHovered = rect.IsHovered();
        bool isPressed = isHovered && curEvent.isMouseDown();
        Color color = isPressed ? colorPressed : isHovered ? colorHovered : colorNormal;
        SetGUIColor(c: color);
        GUI.DrawTexture(position: rect, image: icon.image);
        ResetGUIColor();
        return isHovered && curEvent.isMouseUp();
    }

    internal static void Space(float pixels) => GUILayout.Space(pixels: pixels);

    internal static Rect ExpandWidthLabelRect
        (float height) => GUILayoutUtility.GetRect(content: GUIContent.none, style: GUIStyle.none,
        GUILayout.ExpandWidth(true),
        GUILayout.Height(height: height));

    internal static void MarkInteractive(this Rect rect) { } // Stub - was for debugging/visualization

    internal static class GUIColors
    {
        public static Color selectedBackground => EditorGUIUtility.isProSkin
            ? new Color(0.24f, 0.49f, 0.91f)
            : new Color(0.23f, 0.46f, 0.81f);
    }

    internal static class EditorIcons
    {
        public static Texture GetIcon(string iconName, bool returnNullIfNotFound = false)
        {
            if (string.IsNullOrEmpty(value: iconName))
                return returnNullIfNotFound ? null : Texture2D.whiteTexture;

            GUIContent icon = EditorGUIUtility.IconContent(name: iconName);
            return icon?.image ?? (returnNullIfNotFound ? null : Texture2D.whiteTexture);
        }
    }

    private static void UpdateGUIs()
    {
        foreach (Object dockArea in allDockAreas)
            if (!guis_byDockArea.ContainsKey(key: dockArea))
                guis_byDockArea[key: dockArea] = new TabifyGUI(dockArea: dockArea);

        foreach (Object dockArea in guis_byDockArea.Keys.ToList().Where(r => !r))
            guis_byDockArea.Remove(key: dockArea);

        foreach (TabifyGUI gui in guis_byDockArea.Values)
        {
            gui.UpdateScrollAnimation();
            gui.UpdateLockButtonHiding();
        }
    }

    public static Dictionary<Object, TabifyGUI> guis_byDockArea = new();

    public static void UpdateStyleSheet()
    {
        if (!Application.unityVersion.StartsWith("6000")) return;

        if (AssetDatabase.LoadAssetAtPath<Object>(pluginFolderPath.CombinePath("Tabify.cs")) is null)
        {
            string mainScriptPath = GetScriptPath(nameof(Tabify));
            ProjectPrefs.SetString("tabify-plugin-folder-path", mainScriptPath.GetParentPath());
        }

        bool hasStyleSheet = AssetDatabase.LoadAssetAtPath<StyleSheet>(assetPath: styleSheetPath) != null;
        bool shouldHaveStyleSheet =
            (TabifyMenu.tabStyle != 0 || TabifyMenu.backgroundStyle != 0) && !TabifyMenu.pluginDisabled;

        if (shouldHaveStyleSheet && !hasStyleSheet)
        {
            var s = "";

            s +=
                @"
/* This file is generated by Tabify to modify tab style */
/* Feel free to remove it from version control */
                    ";

            if (TabifyMenu.largeTabStyleEnabled)
                s +=
                    @"
/* tab text */
.dragtab
{
    padding-left: 10px;
}

/* tab itself */
.tab
{
    padding-right: 27px;
}
                    ";

            if (TabifyMenu.neatTabStyleEnabled)
                s +=
                    @"
/* tab text */
.dragtab
{
    padding-left: 10px;
}

/* tab itself */
.tab
{
    padding-right: -1px;
}
                    ";

            if (TabifyMenu.ClassicBackgroundEnabled)
                if (isDarkTheme)
                    s +=
                        @"
/* background */
.dockarea
{
     background-color: #262626;
}

/* tab text */
.dragtab
{
     color: #dedede;
}

/* top and bottom bars */
.AppToolbar
{
     background-color: #181818;
}
                    ";

            if (TabifyMenu.ClassicBackgroundEnabled)
            {
                if (!isDarkTheme)
                {
                    s +=
                        @"
/* background */
.dockarea
{
     background-color: #a9a9a9;
}

/* top and bottom bars */
.AppToolbar
{
     background-color: #888888;
}
                    ";
                }
                else { }
            }
            else { }

            if (TabifyMenu.GreyBackgroundEnabled)
                s +=
                    @"
/* background */
.dockarea
{
     background-color: #222222;
}

/* tab text */
.dragtab
{
     color: #dedede;
}

/* top and bottom bars */
.AppToolbar
{
     background-color: #222222;
}
                    ";

            styleSheetPath.EnsureDirExists();
            File.WriteAllText(path: styleSheetPath, contents: s);
            AssetDatabase.ImportAsset(path: styleSheetPath);
            AssetImporter importer = AssetImporter.GetAtPath(path: styleSheetPath);

            importer.userData =
                TabifyMenu.tabStyle + " " + TabifyMenu.backgroundStyle + " " + (isDarkTheme ? 1 : 0);

            importer.Dirty();
            importer.SaveAndReimport();

            EditorUtility.RequestScriptReload();
        }

        if (!shouldHaveStyleSheet && hasStyleSheet)
        {
            Directory.Delete(path: styleSheetsFolderPath, true);
            File.Delete(styleSheetsFolderPath + ".meta");
            AssetDatabase.Refresh();
        }

        if (shouldHaveStyleSheet && hasStyleSheet)
        {
            AssetImporter importer = AssetImporter.GetAtPath(path: styleSheetPath);

            if (importer.userData == null || importer.userData.Length != 5) return;

            var tabStyle = (int)char.GetNumericValue(importer.userData[0]);
            var backgroundStyle = (int)char.GetNumericValue(importer.userData[2]);
            bool wasDarkTheme = (int)char.GetNumericValue(importer.userData[4]) == 1;

            if (tabStyle != TabifyMenu.tabStyle ||
                backgroundStyle != TabifyMenu.backgroundStyle ||
                isDarkTheme != wasDarkTheme)
            {
                var s = "";

                s +=
                    @"
/* This file is generated by Tabify to modify tab style */
/* Feel free to remove it from version control */
                    ";

                if (TabifyMenu.largeTabStyleEnabled)
                    s +=
                        @"
/* tab text */
.dragtab
{
    padding-left: 10px;
}

/* tab itself */
.tab
{
    padding-right: 27px;
}
                    ";

                if (TabifyMenu.neatTabStyleEnabled)
                    s +=
                        @"
/* tab text */
.dragtab
{
    padding-left: 10px;
}

/* tab itself */
.tab
{
    padding-right: -1px;
}
                    ";

                if (TabifyMenu.ClassicBackgroundEnabled && isDarkTheme)
                    s +=
                        @"
/* background */
.dockarea
{
     background-color: #262626;
}

/* tab text */
.dragtab
{
     color: #dedede;
}

/* top and bottom bars */
.AppToolbar
{
     background-color: #181818;
}
                    ";

                if (TabifyMenu.ClassicBackgroundEnabled && !isDarkTheme)
                    s +=
                        @"
/* background */
.dockarea
{
     background-color: #a9a9a9;
}

/* top and bottom bars */
.AppToolbar
{
     background-color: #888888;
}
                    ";

                if (TabifyMenu.GreyBackgroundEnabled)
                    s +=
                        @"
/* background */
.dockarea
{
     background-color: #222222;
}

/* tab text */
.dragtab
{
     color: #dedede;
}

/* top and bottom bars */
.AppToolbar
{
     background-color: #222222;
}
                    ";

                styleSheetPath.EnsureDirExists();
                File.WriteAllText(path: styleSheetPath, contents: s);
                AssetDatabase.ImportAsset(path: styleSheetPath);
                AssetImporter importer1 = AssetImporter.GetAtPath(path: styleSheetPath);

                importer1.userData =
                    TabifyMenu.tabStyle + " " + TabifyMenu.backgroundStyle + " " + (isDarkTheme ? 1 : 0);

                importer1.Dirty();
                importer1.SaveAndReimport();

                EditorUtility.RequestScriptReload();
            }
        }
    }

    private static string pluginFolderPath => ProjectPrefs.GetString("tabify-plugin-folder-path");
    private static string styleSheetsFolderPath => pluginFolderPath.CombinePath("StyleSheets");
    private static string styleSheetPath => pluginFolderPath.CombinePath("StyleSheets/Extensions/common.uss");

    private static void Shortcuts() // globalEventHandler
    {
        if (!curEvent.isKeyDown()) return;
        if (EditorWindow.focusedWindow?.GetType() == t_GameView &&
            t_ShortcutIntegrations.GetMemberValue<bool>("ignoreWhenPlayModeFocused") &&
            Application.isPlaying) return;

        if (curEvent.keyCode == KeyCode.T &&
            curEvent.modifiers is EventModifiers.Control or EventModifiers.Command &&
            TabifyMenu.addTabShortcutEnabled &&
            EditorWindow.mouseOverWindow.GetDockArea() is Object dockArea2 &&
            guis_byDockArea.TryGetValue(key: dockArea2, out TabifyGUI gui2))
        {
            TabifyAddTabWindow.Open(dockArea: dockArea2);
            EditorWindow.mouseOverWindow.Repaint(); // for + button to light up
            curEvent.Use();
        }

        if (curEvent.keyCode == KeyCode.W &&
            curEvent.modifiers is EventModifiers.Control or EventModifiers.Command &&
            TabifyMenu.closeTabShortcutEnabled &&
            EditorWindow.mouseOverWindow.GetDockArea() is Object dockArea &&
            guis_byDockArea.TryGetValue(key: dockArea, out TabifyGUI gui) &&
            gui.tabs.Count != 1)
        {
            gui.CloseTab(tab: gui.activeTab);
            curEvent.Use();
        }

        if (curEvent.keyCode != KeyCode.T) return;
        if (curEvent.modifiers != (EventModifiers.Command | EventModifiers.Shift) &&
            curEvent.modifiers != (EventModifiers.Control | EventModifiers.Shift)) return;

        if (!TabifyMenu.reopenTabShortcutEnabled) return;

        if (EditorWindow.mouseOverWindow.GetDockArea() is not Object dockArea1) return;
        if (!guis_byDockArea.TryGetValue(key: dockArea1, out TabifyGUI gui1)) return;

        gui1.ReopenClosedTab();

        curEvent.Use();
    }

    private static void UpdateBrowserTitle(EditorWindow browser)
    {
        if (mi_VFavorites_CanBrowserBeWrapped != null &&
            mi_VFavorites_CanBrowserBeWrapped.Invoke(null, new[] { browser }).Equals(false)) return;

        var isLocked = browser.GetMemberValue<bool>("isLocked");
        bool isTitleDefault = browser.titleContent.text == "Project";

        if (isLocked)
        {
            bool isOneColumn = browser.GetMemberValue<int>("m_ViewMode") == 0;

            string path = isOneColumn
                ? browser.GetLockedFolderPath_oneColumn()
                : browser.InvokeMethod<string>("GetActiveFolderPath");
            string guid = path.ToGuid();

            string name = path.GetFilename();
            Texture2D icon = EditorGUIUtility.FindTexture("Project");

            if (name.StartsWith("com."))
                if (PackageInfo.FindForAssetPath(assetPath: path) is { } packageInfo)
                    name = packageInfo.displayName;

            if (mi_VFolders_GetIcon != null)
                if (mi_VFolders_GetIcon.Invoke(null, new[] { guid }) is Texture2D iconFromVFolders)
                    icon = iconFromVFolders;

            browser.titleContent = new GUIContent(text: name, image: icon);

            t_DockArea.GetFieldValue<IDictionary>("s_GUIContents").Clear();
        }


        if (isLocked) return;
        if (isTitleDefault) return;

        var name1 = "Project";
        Texture2D icon1 = EditorGUIUtility.FindTexture("Project@2x");

        browser.titleContent = new GUIContent(text: name1, image: icon1);

        t_DockArea.GetFieldValue<IDictionary>("s_GUIContents").Clear();
    }

    private static void UpdatePropertyEditorTitle(EditorWindow propertyEditor)
    {
        var obj = propertyEditor.GetMemberValue<Object>("m_InspectedObject");

        if (!obj) return;

        string name = obj is Component component ? GetComponentName(component: component) : obj.name;
        Texture2D sourceIcon = AssetPreview.GetMiniThumbnail(obj: obj);
        Texture2D adjustedIcon = sourceIcon;

        if (mi_VHierarchy_GetIcon != null)
            if (obj is GameObject gameObject)
                if (mi_VHierarchy_GetIcon.Invoke(null, new[] { gameObject }) is Texture2D iconFromVHierarchy)
                    sourceIcon = iconFromVHierarchy;

        if (!adjustedObjectIconsBySourceIid.TryGetValue(sourceIcon.GetInstanceID(), value: out adjustedIcon))
        {
            adjustedIcon = new(width: sourceIcon.width, height: sourceIcon.height,
                textureFormat: sourceIcon.format, mipCount: sourceIcon.mipmapCount,
                false);
            adjustedIcon.hideFlags = HideFlags.DontSave;
            adjustedIcon.SetPropertyValue("pixelsPerPoint", (sourceIcon.width / 16f).RoundToInt());

            Graphics.CopyTexture(src: sourceIcon, dst: adjustedIcon);

            adjustedObjectIconsBySourceIid[sourceIcon.GetInstanceID()] = adjustedIcon;
        }

        propertyEditor.titleContent = new GUIContent(text: name, image: adjustedIcon);

        propertyEditor.SetMemberValue("m_InspectedObject",
            null); // prevents further title updates from both internal code and Tabify

        t_DockArea.GetFieldValue<IDictionary>("s_GUIContents").Clear();
    }

    public static void UpdateTitle(EditorWindow window)
    {
        if (window == null) return;

        bool isPropertyEditor = window.GetType() == t_PropertyEditor;
        bool isBrowser = window.GetType() == t_ProjectBrowser;

        if (!isPropertyEditor && !isBrowser) return;

        if (isPropertyEditor)
            UpdatePropertyEditorTitle(propertyEditor: window);

        if (isBrowser)
            if (window.GetPropertyValue<bool>("isLocked"))
                UpdateBrowserTitle(browser: window);
    }

    private static void UpdateAllBrowserTitles()
    {
        foreach (EditorWindow r in allBrowsers)
            UpdateBrowserTitle(browser: r);
    }

    private static void UpdateAllPropertyEditorTitles()
    {
        foreach (EditorWindow r in allPropertyEditors)
            UpdatePropertyEditorTitle(propertyEditor: r);
    }

    private static readonly Dictionary<int, Texture2D> adjustedObjectIconsBySourceIid = new();

    private static void WrappedBrowserOnGUI(EditorWindow browser)
    {
        var headerHeight = 26;
        var footerHeight = 21;
        var breadcrubsYOffset = .5f;

        Rect headerRect = browser.position.SetPos(0, 0).SetHeight(f: headerHeight);
        Rect footerRect = browser.position.SetPos(0, 0).SetHeightFromBottom(px: footerHeight);
        Rect listAreaRect = browser.position.SetPos(0, 0).
            AddHeight(f: -footerHeight).
            AddHeightFromBottom(f: -headerHeight);

        Rect breadcrumbsRect = headerRect.AddHeightFromBottom(-breadcrubsYOffset * 2);
        Rect topGapRect = headerRect.SetHeight(breadcrubsYOffset * 2);

        Color breadcrumbsTint = isDarkTheme ? Greyscale(0, .05f) : Greyscale(0, .02f);
        Color topGapColor = isDarkTheme ? Greyscale(.24f) : Greyscale(.8f);

        bool isOneColumn = browser.GetMemberValue<int>("m_ViewMode") == 0;

        Object[] prevSelection = Selection.objects;

        if (isOneColumn &&
            !curEvent.isRepaint() &&
            browser.GetMemberValue("m_AssetTree") is { } m_AssetTree &&
            m_AssetTree.GetMemberValue("data") is { } data)
        {
            var m_rootInstanceID = data.GetMemberValue<EntityId>("m_rootInstanceID");

            if (m_rootInstanceID == 0)
            {
                string folderPath = browser.GetLockedFolderPath_oneColumn();
                int folderIid = AssetDatabase.LoadAssetAtPath<Object>(assetPath: folderPath).
                    GetInstanceID();
                data.SetMemberValue("m_rootInstanceID", (EntityId)folderIid);
                m_AssetTree.InvokeMethod("ReloadData");
            }
            else if (m_rootInstanceID != 0)
            {
                EntityId folderIid1 = m_rootInstanceID;
                string folderPath1 = EditorUtility.EntityIdToObject(entityId: folderIid1).GetPath();
                browser.SetLockedFolderPath_oneColumn(folderPath: folderPath1);
                browser.GetMemberValue("m_SearchFilter")?.
                    SetMemberValue("m_Folders",
                        new[] { folderPath1 }); // needed for breadcrumbs to display correctly
            }

            if (!browser.GetMemberValue<bool>("isLocked"))
            {
                data.SetMemberValue("m_rootInstanceID", (EntityId)0);
                browser.SetLockedFolderPath_oneColumn("Assets");
                m_AssetTree.InvokeMethod("ReloadData");
            }
        }

        // returns the browser to normal state on unlock
        if (!isOneColumn)
        {
            if (curEvent.isMouseUp() && breadcrumbsRect.IsHovered())
            {
                browser.RecordUndo();

                toCallInGUI += () => UpdateBrowserTitle(browser: browser);
                toCallInGUI += browser.Repaint;
            }
            else if (curEvent.isMouseDown() && curEvent.clickCount == 2)
            {
                browser.RecordUndo();

                EditorApplication.delayCall += () => UpdateBrowserTitle(browser: browser);
                EditorApplication.delayCall += browser.Repaint;
            }

            if (curEvent.isKeyDown() && curEvent.holdingCmdOrCtrl() && curEvent.keyCode == KeyCode.Z)
            {
                string curFolderGuid = browser.InvokeMethod<string>("GetActiveFolderPath").ToGuid();

                EditorApplication.delayCall += () =>
                {
                    string delayedFolderGuid = browser.InvokeMethod<string>("GetActiveFolderPath").ToGuid();

                    if (delayedFolderGuid == curFolderGuid) return;

                    int folderIid2 = AssetDatabase.
                        LoadAssetAtPath<Object>(AssetDatabase.GUIDToAssetPath(guid: delayedFolderGuid)).
                        GetInstanceID();

                    browser.InvokeMethod("SetFolderSelection", new[] { (EntityId)folderIid2 }, false);

                    UpdateBrowserTitle(browser: browser);
                };
            }
        }

        if (isOneColumn)
        {
            if (!browser.InvokeMethod<bool>("Initialized"))
                browser.InvokeMethod("Init");

            int m_TreeViewKeyboardControlID = GUIUtility.GetControlID(focus: FocusType.Keyboard);

            browser.InvokeMethod("OnEvent");

            if (curEvent.isMouseDown() && browser.position.SetPos(0, 0).IsHovered())
                t_ProjectBrowser.SetFieldValue("s_LastInteractedProjectBrowser", val: browser);

            // header
            browser.SetFieldValue("m_ListHeaderRect", val: breadcrumbsRect);

            if (curEvent.isRepaint())
                browser.InvokeMethod("BreadCrumbBar");

            breadcrumbsRect.Draw(color: breadcrumbsTint);
            topGapRect.Draw(color: topGapColor);

            breadcrumbsRect.SetHeightFromBottom(1).Draw(Greyscale(.14f));

            // footer
            browser.SetFieldValue("m_BottomBarRect", val: footerRect);
            browser.InvokeMethod("BottomBar");

            // tree
            browser.GetMemberValue("m_AssetTree")?.InvokeMethod("OnGUI", listAreaRect, m_TreeViewKeyboardControlID);

            browser.InvokeMethod("HandleCommandEvents");
        }
        else
        {
            if (!browser.InvokeMethod<bool>("Initialized"))
                browser.InvokeMethod("Init");

            int m_ListKeyboardControlID = GUIUtility.GetControlID(focus: FocusType.Keyboard);

            object startGridSize = browser.GetFieldValue("m_ListArea")?.GetMemberValue("gridSize");

            browser.InvokeMethod("OnEvent");

            if (curEvent.isMouseDown() && browser.position.SetPos(0, 0).IsHovered())
                t_ProjectBrowser.SetFieldValue("s_LastInteractedProjectBrowser", val: browser);

            // header
            browser.SetFieldValue("m_ListHeaderRect", val: breadcrumbsRect);

            browser.InvokeMethod("BreadCrumbBar");

            breadcrumbsRect.Draw(color: breadcrumbsTint);
            topGapRect.Draw(color: topGapColor);

            breadcrumbsRect.SetHeightFromBottom(1).Draw(Greyscale(.14f));

            // footer
            browser.SetFieldValue("m_BottomBarRect", val: footerRect);
            browser.InvokeMethod("BottomBar");

            // list area
            browser.GetFieldValue("m_ListArea").InvokeMethod("OnGUI", listAreaRect, m_ListKeyboardControlID);

            // block grid size changes when ctrl-shift-scrolling
            if (curEvent.holdingCmdOrCtrl())
                browser.GetFieldValue("m_ListArea").SetMemberValue("gridSize", val: startGridSize);

            browser.SetFieldValue("m_StartGridSize", browser.GetFieldValue("m_ListArea").GetMemberValue("gridSize"));

            browser.InvokeMethod("HandleContextClickInListArea", listAreaRect);
            browser.InvokeMethod("HandleCommandEvents");
        }

        if (Selection.objects.SequenceEqual(second: prevSelection)) return;

        allBrowsers.ForEach(r => r?.SetMemberValue("m_InternalSelectionChange", true));

        EditorApplication.delayCall += () =>
            allBrowsers.ForEach(r => r?.SetMemberValue("m_InternalSelectionChange", false));
    }

    private static void UpdateWrappingForBrowser(EditorWindow browser)
    {
        if (!browser.hasFocus) return;
        if (mi_VFavorites_CanBrowserBeWrapped != null &&
            mi_VFavorites_CanBrowserBeWrapped.Invoke(null, new[] { browser }).Equals(false)) return;

        var isLocked = browser.GetMemberValue<bool>("isLocked");
        bool isWrapped = browser.GetMemberValue("m_Parent").GetMemberValue<Delegate>("m_OnGUI").Method ==
                         mi_WrappedBrowserOnGUI;

        if (isLocked && !isWrapped)
        {
            object hostView1 = browser.GetMemberValue("m_Parent");
            Delegate newDelegate = typeof(Tabify).
                GetMethod(nameof(WrappedBrowserOnGUI), bindingAttr: maxBindingFlags).
                CreateDelegate(delegateType: t_EditorWindowDelegate, target: browser);

            hostView1.SetMemberValue("m_OnGUI", val: newDelegate);
            browser.Repaint();
            browser.SetMemberValue("useTreeViewSelectionInsteadOfMainSelection", false);
        }

        if (isLocked) return;
        if (!isWrapped) return;

        object hostView = browser.GetMemberValue("m_Parent");
        object originalDelegate = hostView.InvokeMethod("CreateDelegate", "OnGUI");
        hostView.SetMemberValue("m_OnGUI", val: originalDelegate);
        browser.Repaint();
    }

    private static void UpdateWrappingForAllBrowsers()
    {
        foreach (EditorWindow r in allBrowsers)
            UpdateWrappingForBrowser(browser: r);
    }

    private static void HideTabScrollerButtons()
    {
        if (leftScrollerStyle != null && rightScrollerStyle != null) return;

        if (!guiStylesInitialized) TryInitializeGuiStyles();
        if (!guiStylesInitialized) return;

        if (typeof(GUISkin).GetFieldValue("current")?.
                GetFieldValue<Dictionary<string, GUIStyle>>("m_Styles")?.
                ContainsKey("dragtab scroller prev") !=
            true) return;
        if (typeof(GUISkin).GetFieldValue("current")?.
                GetFieldValue<Dictionary<string, GUIStyle>>("m_Styles")?.
                ContainsKey("dragtab scroller next") !=
            true) return;

        Type t_Styles = typeof(Editor).Assembly.GetType("UnityEditor.DockArea+Styles");

        leftScrollerStyle = t_Styles.GetFieldValue<GUIStyle>("tabScrollerPrevButton");
        rightScrollerStyle = t_Styles.GetFieldValue<GUIStyle>("tabScrollerNextButton");


        if (clearTexture == null)
        {
            clearTexture = new(1, 1);
            clearTexture.hideFlags = HideFlags.DontSave;
            clearTexture.SetPixel(0, 0, color: Color.clear);
            clearTexture.Apply();
        }

        if (leftScrollerStyle == null || rightScrollerStyle == null) return;

        leftScrollerStyle.normal.background = clearTexture;
        rightScrollerStyle.normal.background = clearTexture;
    }

    private static GUIStyle leftScrollerStyle;
    private static GUIStyle rightScrollerStyle;

    private static Texture2D clearTexture;

    private static void ReplaceUnloadedPropertyEditors_withPlaceholderWIndows()
    {
        foreach (EditorWindow propertyEditor in allPropertyEditors)
            if (propertyEditor.GetMemberValue<Object>("m_InspectedObject") == null)

                ScriptableObject.CreateInstance<TabifyPlaceholderWindow>().
                    OpenAndReplacePropertyEditor(propertyEditorToReplace: propertyEditor);
    }

    private static void LoadPropertyEditorInspectedObjects()
    {
        foreach (EditorWindow propertyEditor in allPropertyEditors)
            propertyEditor.InvokeMethod("LoadPersistedObject");
    }

    private static void EnsureActiveTabsVisibleOnScroller()
    {
        foreach (Object dockArea in allDockAreas)
        {
            if (!guis_byDockArea.TryGetValue(key: dockArea, out TabifyGUI gui)) continue;

            float scrollPos = gui.GetTargetScrollPosition();

            if (!scrollPos.Approx(0))
                scrollPos += gui.nonZeroTabScrollOffset;

            dockArea.SetFieldValue("m_ScrollOffset", val: scrollPos);
        }
    }

    public static void RepaintAllDockAreas()
    {
        foreach (Object dockarea in allDockAreas)
            dockarea.InvokeMethod("Repaint");
    }

    [PostProcessBuild]
    private static void OnBuild(BuildTarget _, string __)
    {
        EditorApplication.delayCall += LoadPropertyEditorInspectedObjects;
        EditorApplication.delayCall += UpdateAllPropertyEditorTitles;
    }

    private static void OnDomainReloaded()
    {
        toCallInGUI += UpdateWrappingForAllBrowsers;
        toCallInGUI += UpdateAllBrowserTitles;
    }

    private static void OnSceneOpened(Scene _, OpenSceneMode __)
    {
        LoadPropertyEditorInspectedObjects();
        ReplaceUnloadedPropertyEditors_withPlaceholderWIndows();
        UpdateAllPropertyEditorTitles();
    }

    private static void OnPrefabStageClosing(PrefabStage _) => ReplaceUnloadedPropertyEditors_withPlaceholderWIndows();

    private static void OnProjectLoaded()
    {
        toCallInGUI += EnsureActiveTabsVisibleOnScroller;
        UpdateAllPropertyEditorTitles();
    }

    private static void OnFocusedWindowChanged()
    {
        if (EditorWindow.focusedWindow?.GetType() == t_ProjectBrowser)
            UpdateWrappingForBrowser(browser: EditorWindow.focusedWindow);
    }

    private static void OnWindowUnmaximized()
    {
        UpdateAllPropertyEditorTitles();
        UpdateAllBrowserTitles();
        UpdateWrappingForAllBrowsers();
        EnsureActiveTabsVisibleOnScroller();
    }

    private static void CheckIfFocusedWindowChanged()
    {
        if (prevFocusedWindow != EditorWindow.focusedWindow)
            OnFocusedWindowChanged();

        prevFocusedWindow = EditorWindow.focusedWindow;
    }

    private static EditorWindow prevFocusedWindow;

    private static void CheckIfWindowWasUnmaximized()
    {
        bool isMaximized = EditorWindow.focusedWindow?.maximized == true;

        if (!isMaximized && wasMaximized)
            OnWindowUnmaximized();

        wasMaximized = isMaximized;
    }

    private static bool wasMaximized;

    private static void OnSomeGUI()
    {
        toCallInGUI?.Invoke();
        toCallInGUI = null;

        CheckIfFocusedWindowChanged();
    }

    private static void ProjectWindowItemOnGUI(string _, Rect __) => OnSomeGUI();
    private static void HierarchyWindowItemOnGUI(int _, Rect __) => OnSomeGUI();

    private static Action toCallInGUI;

    private static void DelayCallLoop()
    {
        UpdateAllBrowserTitles();
        UpdateWrappingForAllBrowsers();
        HideTabScrollerButtons();

        EditorApplication.delayCall -= DelayCallLoop;
        EditorApplication.delayCall += DelayCallLoop;
    }

    private static void Update()
    {
        CheckIfFocusedWindowChanged();
        CheckIfWindowWasUnmaximized();
    }

    private static void ComponentTabHeaderGUI(Editor editor)
    {
        if (editor.target is not Component component) return;

        Rect headerRect = ExpandWidthLabelRect(0).MoveY(-48).SetHeight(50).AddWidthFromMid(8);
        Rect nameRect = headerRect.MoveX(43).MoveY(5).SetHeight(20).SetXMax(headerRect.xMax - 50);
        Rect subtextRect = headerRect.MoveX(43).MoveY(22).SetHeight(20);

        Rect maskRect = headerRect.AddWidthFromRight(-45).AddWidth(-50);
        Color maskColor = Greyscale(isDarkTheme ? .24f : .8f);
        maskRect.Draw(color: maskColor);
        SetLabelFontSize(13);
        GUI.Label(position: nameRect, GetComponentName(component: component));
        ResetLabelStyle();
        SetGUIEnabled(false);
        GUI.Label(position: subtextRect, "Component of");
        ResetGUIEnabled();

        Rect goNameRect = subtextRect.MoveX("Component of ".GetLabelWidth() - 3).
            SetWidth(component.gameObject.name.GetLabelWidth(true));

        goNameRect.MarkInteractive();

        SetGUIEnabled(goNameRect.IsHovered() && !mousePressedOnGoName);
        SetLabelBold();

        GUI.Label(position: goNameRect, text: component.gameObject.name);

        ResetGUIEnabled();
        ResetLabelStyle();

        if (curEvent.isMouseDown() && goNameRect.IsHovered())
        {
            mousePressedOnGoName = true;
            curEvent.Use();
        }

        if (curEvent.isMouseUp())
        {
            if (mousePressedOnGoName)
                EditorGUIUtility.PingObject(obj: component.gameObject);

            mousePressedOnGoName = false;
            curEvent.Use();
        }

        if (curEvent.isMouseLeaveWindow() || (!curEvent.isLayout() && !goNameRect.Resize(1).IsHovered()))
            mousePressedOnGoName = false;

        Space(-4);
    }

    private static bool mousePressedOnGoName;

    private static string GetComponentName(Component component)
    {
        if (!component) return "";

        string name = new GUIContent(EditorGUIUtility.ObjectContent(obj: component, component.GetType())).text;
        name = name[(name.LastIndexOf('(') + 1)..];
        name = name[..^1];
        return name;
    }

    private static void SetupExtraScrollerSpace()
    {
        object action = t_WindowAction.GetMethod("CreateWindowMenuItem", bindingAttr: maxBindingFlags).
            Invoke(null, new[] { "Tabify dummy for creating extra space for + button", null, null });

        var extraSpaceAmount = 21f;

        action.SetMemberValue("width", val: extraSpaceAmount);

        MethodInfo mi_ShouldCreateExtraSpace =
            typeof(Tabify).GetMethod("ShouldCreateExtraSpace", bindingAttr: maxBindingFlags);

        var funcDelegate = Delegate.CreateDelegate(type: t_ValidateHandler, method: mi_ShouldCreateExtraSpace);

        action.SetMemberValue("validateHandler", val: funcDelegate);

        Array defaultActions = t_HostView.GetMemberValue<Array>("s_windowActions") ??
                               t_HostView.InvokeMethod<Array>("FetchWindowActionFromAttribute");

        var newActions = Array.CreateInstance(elementType: t_WindowAction, defaultActions.Length + 1);

        Array.Copy(sourceArray: defaultActions, destinationArray: newActions, length: defaultActions.Length);

        newActions.SetValue(value: action, index: defaultActions.Length);

        t_HostView.SetMemberValue("s_windowActions", val: newActions);
    }

    private static bool ShouldCreateExtraSpace
        (EditorWindow window, object _) => TabifyMenu.addTabButtonEnabled &&
                                           window == (window.GetDockArea() as Object)?.GetTabs()?.Last();

    private static void TryInitializeGuiStyles() =>
        EditorWindow.focusedWindow?.SendEvent(EditorGUIUtility.CommandEvent(""));

    private static bool guiStylesInitialized => typeof(GUI).GetFieldValue("s_Skin") != null;

    public static List<EditorWindow> GetTabs
        (this Object dockArea) => dockArea?.GetFieldValue<List<EditorWindow>>("m_Panes");

    public static string GetLockedFolderPath_oneColumn(this EditorWindow browser)
    {
        string path = browser.GetMemberValue<string[]>("m_LastFolders")?.FirstOrDefault();

        if (path is null or "Assets")
            path = browser.GetMemberValue("m_SearchFilter")?.GetMemberValue<string[]>("m_Folders")?.FirstOrDefault() ??
                   "Assets"; // to migrate locked folder paths from 2.0.14

        return path;

        // unlike in two column layout, there's no such concept as active folder path in one column
        // so we have to serialize locked folder path in some unused field
        // m_LastFolders appears to work fine for this purpose
        // m_SearchFilter was used before v2.0.15 but could get changed when moving/creating/deleting assets
    }

    public static void SetLockedFolderPath_oneColumn(this EditorWindow browser, string folderPath)
    {
        browser.SetMemberValue("m_LastFolders", new[] { folderPath });
    }

    [Serializable]
    public class TabInfo
    {
        public string typeName;
        public string menuItemName;
        public int originalTabIndex;
        public string originalTitle;
        public bool wasFocused;
        public bool isLocked;
        public string folderGuid = "";
        public int savedGridSize;
        public int savedLayout;
        public bool isGridSizeSaved;
        public bool isLayoutSaved;
        public GlobalID globalId;
        public Object lockedPrefabAssetObject;
        public object originalDockArea;

        public bool isBrowser => typeName == t_ProjectBrowser.Name;

        public bool isPropertyEditor => typeName == t_PropertyEditor.Name;

        public TabInfo(EditorWindow window)
        {
            typeName = window.GetType().Name;
            originalDockArea = window.GetDockArea();
            originalTabIndex = (originalDockArea as Object)?.GetTabs().IndexOf(item: window) ?? -1;
            wasFocused = window.hasFocus;
            originalTitle = window.titleContent.text;
            menuItemName = window.titleContent.text.Replace("/", " \u2215 ").Trim(' ');

            if (isBrowser)
            {
                isLocked = window.GetPropertyValue<bool>("isLocked");

                savedGridSize = window.GetFieldValue<int>("m_StartGridSize");

                isGridSizeSaved = true;

                savedLayout = window.GetMemberValue<int>("m_ViewMode");

                isLayoutSaved = true;

                string folderPath = savedLayout == 0
                    ? window.GetLockedFolderPath_oneColumn() // one column
                    : window.InvokeMethod<string>("GetActiveFolderPath"); // two columns
                folderGuid = folderPath.ToGuid();
            }

            if (isPropertyEditor)
                globalId = new GlobalID(window.GetMemberValue<string>("m_GlobalObjectId"));
        }

        public TabInfo(Object lockTo)
        {
            isLocked = true;
            typeName = lockTo is DefaultAsset ? t_ProjectBrowser.Name : t_PropertyEditor.Name;

            if (isBrowser)
                folderGuid = AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(assetObject: lockTo));

            if (isPropertyEditor)
                globalId = lockTo.GetGlobalID();

            if (isPropertyEditor)
                if (StageUtility.GetCurrentStage() is PrefabStage &&
                    globalId.ToString().Contains("00000000000000000000000000000000"))
                    lockedPrefabAssetObject = lockTo;
        }

        public TabInfo(string typeName, string menuItemName)
        {
            this.typeName = typeName;
            this.menuItemName = menuItemName;
        }
    }

    [Serializable]
    private class TabInfoList
    {
        public List<TabInfo> list = new();
    }

    [InitializeOnLoadMethod]
    private static void Init()
    {
        if (TabifyMenu.pluginDisabled) return;

        EditorApplication.update -= UpdateGUIs;
        EditorApplication.update += UpdateGUIs;

        // shortcuts
        var globalEventHandler =
            typeof(EditorApplication).GetFieldValue<EditorApplication.CallbackFunction>("globalEventHandler");
        typeof(EditorApplication).SetFieldValue("globalEventHandler", globalEventHandler - Shortcuts + Shortcuts);

        // component tabs
        Editor.finishedDefaultHeaderGUI -= ComponentTabHeaderGUI;
        Editor.finishedDefaultHeaderGUI += ComponentTabHeaderGUI;

        // state change detectors
        var projectWasLoaded =
            typeof(EditorApplication).GetFieldValue<UnityAction>("projectWasLoaded");
        typeof(EditorApplication).SetFieldValue("projectWasLoaded",
            projectWasLoaded - OnProjectLoaded + OnProjectLoaded);

        EditorSceneManager.sceneOpened -= OnSceneOpened;
        EditorSceneManager.sceneOpened += OnSceneOpened;

        EditorApplication.projectWindowItemOnGUI -= ProjectWindowItemOnGUI;
        EditorApplication.projectWindowItemOnGUI += ProjectWindowItemOnGUI;

        EditorApplication.hierarchyWindowItemOnGUI -= HierarchyWindowItemOnGUI;
        EditorApplication.hierarchyWindowItemOnGUI += HierarchyWindowItemOnGUI;

        EditorApplication.delayCall -= DelayCallLoop;
        EditorApplication.delayCall += DelayCallLoop;

        EditorApplication.update -= Update;
        EditorApplication.update += Update;

        EditorApplication.quitting -= TabifyCache.Save;
        EditorApplication.quitting += TabifyCache.Save;

        PrefabStage.prefabStageClosing += OnPrefabStageClosing;

        // EditorApplication.delayCall += () => TabifyAddTabWindow.UpdateAllEntries();

        EditorApplication.delayCall += () => UpdateStyleSheet();

        SetupExtraScrollerSpace();

        OnDomainReloaded();
    }

    public static IEnumerable<EditorWindow> allBrowsers => _allBrowsers ??=
        t_ProjectBrowser.GetFieldValue<IList>("s_ProjectBrowsers").Cast<EditorWindow>();

    public static IEnumerable<EditorWindow> _allBrowsers;

    public static IEnumerable<EditorWindow> allPropertyEditors => Resources.
        FindObjectsOfTypeAll(type: t_PropertyEditor).
        Where(r => r.GetType().BaseType == typeof(EditorWindow)).
        Cast<EditorWindow>();

    public static List<EditorWindow> allEditorWindows
    {
        get
        {
            if (typeof(EditorWindow).GetPropertyInfo("activeEditorWindows") ==
                null) // this variable doesn't exist in early 2022.3 versions, even though UnityCsReference repo says it does
                return Resources.FindObjectsOfTypeAll(typeof(EditorWindow)).Cast<EditorWindow>().ToList();

            return _allEditorWindows ?? typeof(EditorWindow).GetMemberValue<List<EditorWindow>>("activeEditorWindows");
        }
    }

    public static List<EditorWindow> _allEditorWindows;

    public static IEnumerable<Object> allDockAreas => allEditorWindows.Where(r => r.hasFocus && !r.maximized).
        Select(r => r.GetMemberValue<Object>("m_Parent")).
        Where(r => r.GetType() == t_DockArea);

    public static Type t_DockArea = typeof(Editor).Assembly.GetType("UnityEditor.DockArea");
    public static Type t_PropertyEditor = typeof(Editor).Assembly.GetType("UnityEditor.PropertyEditor");
    public static Type t_ProjectBrowser = typeof(Editor).Assembly.GetType("UnityEditor.ProjectBrowser");
    public static Type t_SceneHierarchyWindow = typeof(Editor).Assembly.GetType("UnityEditor.SceneHierarchyWindow");
    public static Type t_InspectorWindow = typeof(Editor).Assembly.GetType("UnityEditor.InspectorWindow");
    public static Type t_WindowAction = typeof(Editor).Assembly.GetType("UnityEditor.WindowAction");
    public static Type t_HostView = typeof(Editor).Assembly.GetType("UnityEditor.HostView");

    public static Type t_EditorWindowDelegate =
        t_HostView.GetNestedType("EditorWindowDelegate", bindingAttr: maxBindingFlags);

    public static Type t_ValidateHandler =
        t_WindowAction.GetNestedType("ValidateHandler", bindingAttr: maxBindingFlags);

    public static Type t_EditorWindowShowButtonDelegate =
        t_HostView.GetNestedType("EditorWindowShowButtonDelegate", bindingAttr: maxBindingFlags);

    public static Type t_GameView = typeof(Editor).Assembly.GetType("UnityEditor.GameView");

    public static Type t_ShortcutIntegrations =
        typeof(Editor).Assembly.GetType("UnityEditor.ShortcutManagement.ShortcutIntegration");

    public static Type t_VHierarchy = Type.GetType("VHierarchy.VHierarchy") ??
                                      Type.GetType(
                                          "VHierarchy.VHierarchy, VHierarchy, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null");

    public static Type t_VFolders = Type.GetType("VFolders.VFolders") ??
                                    Type.GetType(
                                        "VFolders.VFolders, VFolders, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null");

    public static Type t_VFavorites = Type.GetType("VFavorites.VFavorites") ??
                                      Type.GetType(
                                          "VFavorites.VFavorites, VFavorites, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null");

    public static MethodInfo mi_WrappedBrowserOnGUI =
        typeof(Tabify).GetMethod(nameof(WrappedBrowserOnGUI), bindingAttr: maxBindingFlags);

    public static MethodInfo mi_VFolders_GetIcon =
        t_VFolders?.GetMethod("GetSmallFolderIcon_forVTabs", bindingAttr: maxBindingFlags);

    public static MethodInfo mi_VHierarchy_GetIcon =
        t_VHierarchy?.GetMethod("GetIcon_forVTabs", bindingAttr: maxBindingFlags);

    public static MethodInfo mi_VFavorites_BeforeWindowCreated =
        t_VFavorites?.GetMethod("BeforeWindowCreated_byVTabs", bindingAttr: maxBindingFlags);

    public static MethodInfo mi_VFavorites_CanBrowserBeWrapped =
        t_VFavorites?.GetMethod("CanBrowserBeWrapped_byVTabs", bindingAttr: maxBindingFlags);

    private const string version = "2.1.5";
}
#endif